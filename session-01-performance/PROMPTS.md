# [Session 01] AI 활용 프롬프트 -- 성능/캐시

## 1단계: 이해 (개념 학습)

> 이 단계에서는 AI에게 질문하여 핵심 개념을 빠르게 이해합니다.

```
p50, p95, p99 응답시간의 차이를 설명해줘.
우리 서비스의 평균 응답시간이 200ms인데 p99가 5초라면 어떤 문제가 있는 거야?
```

```
Redis 캐시의 cache-aside, write-through, write-behind 3가지 패턴을 비교해줘.
각각 어떤 상황에 적합한지, 장단점을 표로 정리해줘.
```

```
캐시 무효화(invalidation) 전략 3가지를 설명해줘:
1. TTL 기반
2. 이벤트 기반 (데이터 변경 시 캐시 삭제)
3. Write-through (쓰기 시 캐시도 함께 갱신)
각각의 장단점과 적합한 상황을 알려줘.
```

## 2단계: 적용 (코드 작성)

> 이 단계에서는 AI와 함께 코드를 작성합니다. AI가 생성한 코드를 반드시 이해하고 검토하세요.

```
Spring Boot + RedisTemplate으로 cache-aside 패턴을 구현해줘.
다음 요구사항을 반영해:
- 메뉴 목록 조회 API에 적용
- TTL은 5분
- 캐시 키는 "menus:{restaurantId}" 형식
- 캐시 미스 시 DB 조회 후 캐시 저장
- ObjectMapper로 JSON 직렬화/역직렬화
```

```
Spring Boot에서 @Cacheable의 key 생성 전략을 커스터마이징하는 방법을 알려줘.
복합 키(여러 파라미터 조합)를 사용하는 예제도 포함해줘.
```

## 3단계: 검증 (비판적 검토)

> 이 단계에서는 AI의 답변이나 생성한 코드의 잠재적 문제를 찾습니다.

```
이 캐시 코드에서 캐시 스탬피드(Cache Stampede)가 발생할 수 있어?
TTL이 만료되는 시점에 동시에 1000개의 요청이 오면 어떻게 돼?
방지 방법(뮤텍스 패턴, 사전 갱신 등)을 코드로 보여줘.
```

```
Redis가 다운되면 우리 서비스는 어떻게 되는 거야?
캐시 장애 시에도 서비스가 정상 동작하도록 하는 방법(fallback)을 알려줘.
```

```
[AI가 틀릴 수 있는 포인트]
AI가 추천한 TTL 값이나 캐시 전략은 실제 트래픽 패턴을 모르기 때문에
최적이 아닐 수 있습니다. 반드시 실제 데이터로 검증하세요.
- 실제 캐시 적중률은 Redis INFO 명령어로 확인
- 실제 응답 시간은 curl이나 부하 테스트 도구로 측정
```
