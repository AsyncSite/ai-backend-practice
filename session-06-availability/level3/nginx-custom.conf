# =============================================================================
# [Session 06 - Level 3] Nginx 고가용성 설정 직접 구성
# =============================================================================
# 이 파일을 직접 완성하여 Nginx 로드밸런서를 구성합니다.
#
# 학습 목표:
#   1. upstream 블록으로 백엔드 서버 그룹 구성
#   2. 가중치(weight) 기반 로드밸런싱 설정
#   3. 헬스체크로 장애 서버 자동 제외
#   4. Rate Limiting으로 과부하 방지
#
# 테스트 방법:
#   1. 이 파일을 완성한 후 infra/nginx/nginx.conf에 복사
#   2. docker compose --profile ha up -d
#   3. curl http://localhost/api/restaurants 로 테스트
#   4. docker stop grit-app-replica 로 서버 1대 중지 후 확인
# =============================================================================

worker_processes auto;

events {
    worker_connections 1024;
}

http {

    # =========================================================================
    # 1단계: Rate Limiting 설정
    # =========================================================================

    # TODO 1: Rate Limiting Zone을 정의하세요
    #
    # Rate Limiting: 클라이언트별 요청 수를 제한하여 서버 과부하를 방지합니다.
    #
    # 설정할 값:
    #   - zone 이름: api_limit
    #   - 메모리: 10m (약 16만 개의 IP 주소 저장 가능)
    #   - 제한: 10r/s (초당 10개 요청)
    #   - 키: $binary_remote_addr (클라이언트 IP 기준)
    #
    # 힌트:
    #   limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;


    # =========================================================================
    # 2단계: Upstream 서버 그룹 정의
    # =========================================================================

    # TODO 2: upstream 블록을 구성하세요
    #
    # 요구사항:
    #   - 이름: backend
    #   - 앱 서버 1 (app:8080): weight=3 (성능 좋은 서버에 더 많은 트래픽)
    #   - 앱 서버 2 (app-replica:8080): weight=1
    #   - max_fails=3: 3번 연속 실패 시 해당 서버를 비정상으로 판단
    #   - fail_timeout=30s: 비정상 판단 후 30초 동안 요청 보내지 않음
    #
    # 힌트:
    #   upstream backend {
    #       server app:8080 weight=??? max_fails=??? fail_timeout=???;
    #       server app-replica:8080 weight=??? max_fails=??? fail_timeout=???;
    #   }


    server {
        listen 80;
        server_name localhost;

        # =====================================================================
        # 3단계: 헬스체크 엔드포인트
        # =====================================================================

        # TODO 3: Nginx 자체 헬스체크 엔드포인트를 만드세요
        #
        # 로드밸런서가 살아있는지 확인하는 용도입니다.
        # 모니터링 시스템이 이 엔드포인트를 주기적으로 호출합니다.
        #
        # 힌트:
        #   location /nginx-health {
        #       return 200 'Nginx is healthy';
        #       add_header Content-Type text/plain;
        #   }


        # =====================================================================
        # 4단계: API 프록시 설정
        # =====================================================================

        # TODO 4: 모든 API 요청을 백엔드로 프록시하세요
        #
        # 설정할 항목:
        #   a) proxy_pass: upstream 그룹으로 전달
        #   b) 프록시 헤더: 원본 클라이언트 정보 전달
        #   c) 타임아웃: 연결 5초, 읽기 30초, 전송 30초
        #   d) 장애 전환: 에러/타임아웃 시 다음 서버로
        #   e) Rate Limiting 적용
        #
        # 힌트:
        #   location / {
        #       # Rate Limiting 적용 (burst=20: 순간적으로 20개 초과 요청 허용)
        #       limit_req zone=api_limit burst=20 nodelay;
        #
        #       # 백엔드로 프록시
        #       proxy_pass http://backend;
        #
        #       # 프록시 헤더 설정
        #       proxy_set_header Host $host;
        #       proxy_set_header X-Real-IP $remote_addr;
        #       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        #       proxy_set_header X-Forwarded-Proto $scheme;
        #
        #       # 타임아웃 설정
        #       proxy_connect_timeout 5s;
        #       proxy_read_timeout 30s;
        #       proxy_send_timeout 30s;
        #
        #       # 서버 장애 시 다음 서버로 자동 전환
        #       proxy_next_upstream error timeout http_502 http_503 http_504;
        #       proxy_next_upstream_tries 2;
        #   }


        # =====================================================================
        # 5단계: 에러 페이지 (심화)
        # =====================================================================

        # TODO 5: 모든 백엔드가 다운되었을 때 사용자 친화적인 에러 응답을 반환하세요
        #
        # 힌트:
        #   error_page 502 503 504 /custom_error;
        #   location = /custom_error {
        #       return 503 '{"error": "서비스 점검 중입니다. 잠시 후 다시 시도해주세요."}';
        #       add_header Content-Type 'application/json; charset=utf-8';
        #   }
    }

    # =========================================================================
    # 6단계: 로그 설정
    # =========================================================================

    # TODO 6: 커스텀 로그 형식을 정의하세요
    #
    # 포함할 정보: 클라이언트 IP, 요청 정보, 상태 코드, 응답 시간, 업스트림 서버
    # 응답 시간과 업스트림 서버 정보는 로드밸런싱 디버깅에 필수입니다.
    #
    # 힌트:
    #   log_format main '$remote_addr - $remote_user [$time_local] '
    #                   '"$request" $status $body_bytes_sent '
    #                   '"$http_referer" "$http_user_agent" '
    #                   'upstream=$upstream_addr response_time=$upstream_response_time';
    #
    #   access_log /var/log/nginx/access.log main;
    #   error_log  /var/log/nginx/error.log warn;
}
